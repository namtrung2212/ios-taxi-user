// Generated by Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.31)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import CoreData;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"


/// Base class for MemoryStorage and CoreDataStorage
SWIFT_CLASS("_TtC14DTModelStorage11BaseStorage")
@interface BaseStorage : NSObject

/// Supplementary kind for header in current storage
@property (nonatomic, copy) NSString * _Nullable supplementaryHeaderKind;

/// Supplementary kind for footer in current storage
@property (nonatomic, copy) NSString * _Nullable supplementaryFooterKind;

/// Batch updates are in progress. If true, update will not be finished.
@property (nonatomic) BOOL batchUpdatesInProgress;

/// Perform update in storage. After update is finished, delegate will be notified. Parameter block: Block to execute\Note 
///
/// This method allows to execute several updates in a single batch. It is similar to UICollectionView method <code>performBatchUpdates:
/// </code>.\Warning 
///
/// Performing mutual exclusive updates inside block can cause application crash.
- (void)performUpdates:(void (^ _Nonnull)(void))block;

/// Start update in storage. This creates StorageUpdate instance and stores it into currentUpdate property.
- (void)startUpdate;

/// Finished update. Method verifies, that update is not empty, and sends updates to the delegate. After this method finishes, currentUpdate property is nilled out.
- (void)finishUpdate;

/// This method will configure storage for using with UITableView
- (void)configureForTableViewUsage;

/// This method will configure storage for using with UICollectionViewFlowLayout
- (void)configureForCollectionViewFlowLayoutUsage;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSFetchedResultsController;
@class NSIndexPath;
@protocol NSFetchedResultsSectionInfo;


/// This class represents model storage in CoreData It uses NSFetchedResultsController to monitor all changes in CoreData and automatically notify delegate of any changes
SWIFT_CLASS("_TtC14DTModelStorage15CoreDataStorage")
@interface CoreDataStorage : BaseStorage <NSFetchedResultsControllerDelegate>

/// Fetched results controller of storage
@property (nonatomic, readonly, strong) NSFetchedResultsController * _Nonnull fetchedResultsController;

/// Initialize CoreDataStorage with NSFetchedResultsController
///
/// \param fetchedResultsController fetch results controller
- (nonnull instancetype)initWithFetchedResultsController:(NSFetchedResultsController * _Nonnull)fetchedResultsController OBJC_DESIGNATED_INITIALIZER;

/// NSFetchedResultsController is about to start changing content - we'll start monitoring for updates.
- (void)controllerWillChangeContent:(NSFetchedResultsController * _Nonnull)controller;

/// React to specific change in NSFetchedResultsController
- (void)controller:(NSFetchedResultsController * _Nonnull)controller didChangeObject:(id _Nonnull)anObject atIndexPath:(NSIndexPath * _Nullable)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath * _Nullable)newIndexPath;

/// React to changed section in NSFetchedResultsController
- (void)controller:(NSFetchedResultsController * _Nonnull)controller didChangeSection:(id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfo atIndex:(NSInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type;

/// Finish update from NSFetchedResultsController
- (void)controllerDidChangeContent:(NSFetchedResultsController * _Nonnull)controller;
@end

@class NSIndexSet;


/// This class represents model storage in memory.
///
/// <code>MemoryStorage
/// </code> stores data models like array of <code>SectionModel
/// </code> instances. It has various methods for changing storage contents - add, remove, insert, replace e.t.c.\Note 
///
/// It also notifies it's delegate about underlying changes so that delegate can update interface accordingly\See 
///
/// <code>SectionModel
/// </code>
SWIFT_CLASS("_TtC14DTModelStorage13MemoryStorage")
@interface MemoryStorage : BaseStorage

/// Remove items at index paths.
///
/// \param indexPaths indexPaths to remove item from. Any indexPaths that will not be found, will be skipped
- (void)removeItemsAtIndexPaths:(NSArray<NSIndexPath *> * _Nonnull)indexPaths;

/// Delete sections in indexSet
///
/// \param sections sections to delete
- (void)deleteSections:(NSIndexSet * _Nonnull)sections;

/// Move section from sourceSectionIndex to destinationSectionIndex.
///
/// \param sourceSectionIndex index of section, from which we'll be moving
///
/// \param destinationSectionIndex index of section, where we'll be moving
- (void)moveSection:(NSInteger)sourceSectionIndex toSection:(NSInteger)destinationSectionIndex;

/// Move item from source indexPath to destination indexPath.
///
/// \param source indexPath from which we need to move
///
/// \param toIndexPath destination index path for item
- (void)moveItemAtIndexPath:(NSIndexPath * _Nonnull)source toIndexPath:(NSIndexPath * _Nonnull)destination;

/// Remove all items.\Note 
///
/// method will call .reloadData() when it finishes.
- (void)removeAllItems;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface MemoryStorage (SWIFT_EXTENSION(DTModelStorage))

/// This method allows multiple simultaneous changes to memory storage without any notifications for delegate.
///
/// You can think of this as a way of "manual" management for memory storage. Typical usage would be multiple insertions/deletions etc., if you don't need any animations. You can batch any changes in block, and call reloadData on your UI component after this method was call.\Note 
///
/// You must call reloadData after calling this method, or you will get NSInternalInconsistencyException runtime, thrown by either UITableView or UICollectionView.
///
/// \param block block to execute with MemoryStorage.
- (void)updateWithoutAnimations:(void (^ _Nonnull)(void))block;
@end

@class NSBundle;

@interface UINib (SWIFT_EXTENSION(DTModelStorage))

/// Check whether nib with name exists in bundle
///
/// \param nibName Name of xib file
///
/// \param inBundle bundle to search in
///
/// \returns  true, if nib exists, false - if not.
+ (BOOL)nibExistsWithNibName:(NSString * _Nonnull)nibName inBundle:(NSBundle * _Nonnull)bundle;
@end

#pragma clang diagnostic pop
